import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/*
 * (미완)
 * <문제 요약>
 * 문제 정의 : 부분 문자열인지 구하여라.
 * 문제 유형 : KMP.
 * <풀이 요약>
 * 1. 실패 함수를 구한다 : 실패 함수는 쉽게 말해, j포인터가 이동할 인덱스를 알려주는 정보들이다.
 * -> 패턴 문자열을 나란히 놓고 비교하며 실패 함수를 구한다.
 * -> 주의 : 실패 함수를 구하는 과정에서 지금까지 구해진 실패 함수를 이용해서 나머지 실패 함수를 구한다.
 * -> 두 개의 포인터 i와 j를 만든다.
 * -> 포인터 i는 접미사를 접미사를 의미하는 포인터이고, j는 접두사를 의미하는 포인터이다.
 * -> 따라서 i는 인덱스가 1인 지점부터 시작하고, j는 인덱스가 0인 지점부터 시작하게 된다.
 * (1) i와 j가 같은 경우
 * -> 접두사와 접미사가 일치하는 상태이다. i와 j의 인덱스를 동시에 증가 시킨다.
 * -> 이때 j가 있는 위치가 접두사와 접미사가 일치하는 부분의 길이이므로 j의 값을 저장한다.
 * (2) i와 j가 같지 않은 경우.
 * -> 접두사와 접미사가 일치하지 않는 상태이다. 
 * -> 단, 이전 부분 까지는 접두사와 접미사가 일치하던 상태였다.
 * -> 따라서 이전 부분의 실패 함수를 참고하여, 해당 인덱스에서 최대로 겹쳤던 인덱스로 j를 이동시킨다.
 * -> 이렇게 처리한다면 j는 이전 부분을 기준으로 접미사와 접두사가 일치하는 부분으로 포인터를 이동한 상태일 것이다.
 * (3) 1번과 2번을 i가 패턴 문자열을 모두 탐색할 때 까지 반복한다.
 * -> 이때, 실패 함수의 인덱스가 0인 지점은 j가 최대로 왼쪽으로 이동할 수 있는 값이 들어가야 하므로 0으로 초기화한다.
 * 2. KMP 알고리즘을 적용한다.
 * -> 이번에는 본래 문자열과 패턴 문자열을 비교한다.
 * -> 마찬가지로 포인터 i와 j를 둔다. 이때, i는 본래 문자열을 가리키는 포인터이고 j는 패턴 문자열을 가리키는 포인터이다.
 * (1) i와 j가 같은 경우
 * -> 문자열이 서로 일치하는 상태이다. i와 j의 값을 증기시킨다.
 * -> 단, j의 값이 패턴 문자열의 전체 길이까지 도달하였다면 부분 문자열이 존재하는 것이다. 1을 출력한다.
 * (2) i와 j가 다른 경우
 * -> 문자열이 서로 일치하지 않는 상태이다. 실패 함수를 참고하여 j의 포인터를 옮긴다.
 * -> 즉, 이전 부분까지는 일치했다는 의미이므로 이전 부분의 실패함수를 참고하여 j가 어디로 이동하면 좋을지 참고한다.
 * <피드백>
 * 1. 진짜 역대급으로 어렵다 슈빌..
 * 2. 문자열의 길이를 구하는 함수가 반복문 안에 들어가서 시간 복잡도의 영향은 없는 것 같다.
 * -> 그렇지만, 안정성(문자열의 길이가 변하는 경우)의 문제로 변수를 따로 선언해주는 것이 좋다.
 */
public class BOJ_G4_16916_부분문자열 {
	static String origin, pattern;
	static int[] fail;
	
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		origin = br.readLine();
		pattern = br.readLine();
		int olength = origin.length();
		int plength = pattern.length();
		fail = new int[plength];
		
		// 1. 실패 함수 구하기.
		// 포인터 j는 접두사를 가리킨다. i와 같거나 다른 경우에 따라 전진하거나 후진한다.
		int j = 0;
		// 포인터 i는 접미사를 가리킨다. 따라서 1부터 시작한다.
		for(int i = 1; i < plength; i++) {
			
			// j는 일단 1칸이상 전진한 상태이고, i와 j가 다른 경우(후진).
			while(j > 0 && pattern.charAt(i) != pattern.charAt(j)) {
				// 실패 함수를 참고하여 j의 위치를 옮긴다.
				j = fail[j - 1];
			}
			
			// 그 외, j와 i가 일치하는 경우
			if(pattern.charAt(i) == pattern.charAt(j)) {
				// 현재 i의 위치에 실패 함수의 값을 전진한 j의 값으로 설정한다.
				fail[i] = ++j;
			}
		}
		
		// 2. KMP 알고리즘 적용하기.
		// 포인터 j는 패턴 문자열을 가리킨다. j가 패턴 문자열의 길이와 일치하는 순간 부분 문자열이 존재한다고 판단한다.
		j = 0;
		// 포인터 i는 원본(전체) 문자열을 가리킨다. i가 전체 문자열을 훑을 때까지 j가 패턴 문자열의 길이와 일치하지 않는다면 부분 문자열은 존재하지 않는다.
		for(int i = 0; i < olength; i++) {
			// i와 j가 다른 경우, j의 위치를 실패함수 값을 참고하여 수정(실패 함수를 구할 때와 같다).
			while(j > 0 && origin.charAt(i) != pattern.charAt(j)) {
				// 실패 함수를 참고하여 j의 위치를 옮긴다.
				j = fail[j - 1];
			}
			// i와 j가 같은 경우, j를 전진 시키고 문자열의 길이와 일치하는지 판단.
			if(origin.charAt(i) == pattern.charAt(j)) {
				if(j == plength - 1) {
					System.out.println(1);
					return;
				}
				j++;
			}
		}
		
		// 여기까지 왔으면 부분 문자열이 존재하지 않는다!
		System.out.println(0);
	}
}

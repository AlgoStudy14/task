package s0703;

import java.util.Scanner;

/*
 * (미완)
 * <문제 요약>
 * 문제 정의 : 가장 긴 증가하는 부분 수열의 길이를 구하여라.
 * 문제 유형 : (DP), (DP + 이분 탐색).
 * 주의 사항 : 부분 수열은 인접한 두 수열만 의미하는 것이 아니다.
 * <풀이 요약 : DP : N^2>
 * 1. N번째 숫자를 붙였을 때 가장 긴 수열의 길이를 저장할 1차원 DP 테이블을 선언한다.
 * 2. N번째 숫자에 대하여, 앞선 숫자들을 비교하며 해당 숫자보다 N번째 수가 크다면 해당 DP테이블의 값에 1을 더하여 저장하며 최대 값을 갱신한다.
 * -> 즉, 우선 dp테이블의 모든 값을 1로 초기화가 가능하다(자신만 존재하는 경우).
 * -> 점화식은 다음과 같아진다 : dp[i] = Math.max(dp[0] + 1, dp[1] + 1, ... dp[i - 1] + 1, dp[i])(단, i번째 이전 수 < i번째 수).
 * <피드백>
 * 1. 우선 이 문제는 입력의 최대 크기가 1000밖에 안되기 때문에, N^2의 DP로도 처리가 가능하다.
 * 2. DP는 이전 인덱스 값과의 연관 관계로만 생각하지 않아도 된다. 이전에 기록된 값을 모두 고려해볼 수 있다는 것을 생각하게 해준 문제(점화식을 자유롭게 생각해본다).
 * 
 * <풀이 요약 : DP + 이분 탐색 : NlogN>
 * 1. N번째 숫자가 아닌 현재 작성된 배열의 크기가 곧 LIS의 길이인 배열을 저장할 dp테이블을 선언한다.
 * 2. 여기서는 '길이'를 기반으로 테이블을 갱신하지 않는다. 대신, 현재까지 비교한 마지막 원소의 값과 다음 대상 수를 비교하며 배열 자체의 원소들을 갱신한다.
 * -> 만일 N번째 숫자가 1 ~ N - 1번째의 숫자보다 작다면, 해당 위치의 값을 해당 숫자로 덮어 씌운다.
 * -> 이 과정에서 앞의 숫자들은 자동적으로 '정렬된 상태'이므로 이분 탐색을 활용하여 덮어 씌울 위치를 찾는다(logN).
 * -> 이렇게 완성된 배열의 '크기'가 LIS의 '길이'와 같다.
 * (원리)
 * -> 어차피 덮어씌워지는 위치는 현재까지 쌓인 배열 중 가장 작은 값의 위치와 바뀌기 때문에 마지막 숫자는 현재까지 증가하는 부분 수열 중 가장 큰 값을 유지한다.
 * -> 또한, 해당 숫자를 덮어씌우는 과정에서 원소의 길이는 유지 된다.
 */

public class BOJ_S2_11053_가장긴증가하는부분수열 {
	static int N;
	static int[] nums, dp;
	static int max;
	
	// DP + 이분 탐색
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		N = sc.nextInt();
		nums = new int[N];
		for(int i = 0; i < N; i++) {
			nums[i] = sc.nextInt();
		}
		
		// 현재까지 저장된 배열의 크기 = LIS의 길이를 저장할 dp테이블을 만든다(배열의 크기는 최대 N).
		dp = new int[N];
		
		// 1번째 위치부터 N번째 위치까지 고려한다.
		for(int i = 0; i < N; i++) {
			// 현재 위치의 값이 앞선 모든 원소들 중 가장 작은 값보다 작다면, 해당 위치를 현재 위치의 값으로 덮어 씌운다.
			
		}
		
		sc.close();
	}
	
	// DP : N^2
//	public static void main(String[] args) {
//		Scanner sc = new Scanner(System.in);
//		N = sc.nextInt();
//		nums = new int[N];
//		for (int i = 0; i < N; i++) {
//			nums[i] = sc.nextInt();
//		}
//		
//		// dp 테이블 선언.
//		dp = new int[N];
//		
//		// 1번째 숫자부터 N번째 숫자까지 dp테이블을 채워나간다.
//		max = Integer.MIN_VALUE;
//		for(int i = 0; i < N; i++) {
//			// 우선, 현재 선택된 숫자의 dp테이블 값을 1로 초기화(자기 자신만 존재하는 경우의 길이).
//			dp[i] = 1;
//			// 현재 선택된 숫자에 대하여, 앞선 숫자들을 비교하며 dp테이블을 갱신한다.
//			for(int j = 0; j < i; j++) {
//				// 단, 앞 숫자가 현재 숫자보다 작은 경우만 고려한다.
//				if(nums[j] < nums[i])
//					dp[i] = Math.max(dp[i], dp[j] + 1);
//			}
//			// 현재 위치의 갱신 후, 현재까지 구해진 최대 값을 갱신한다.
//			max = Math.max(max, dp[i]);
//		}
//		
//		System.out.println(max);
//		sc.close();
//	}
}

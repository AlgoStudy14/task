package s0703;

/*
 * (완)
 * <문제 요약>
 * 문제 정의 : 원 모양으로 배치된 집에서, 도둑이 인접한 두 집을 털수는 없을 때 도둑이 털 수 있는 가장 큰 금액은?
 * 문제 유형 : DP.
 * <풀이 요약>
 * 1. 도둑이 n번째 집을 털었을 때 가질 수 있는 최대 비용을 저장할 1차원 dp테이블을 만든다.
 * 2. 첫 번째 집부터 n번째 집까지 차례차례 도둑이 가져갈 수 있는 최대 비용을 갱신해 나아간다.
 * -> n번째 집에서 털 수 있는 최대 비용 = Math.max(n번째 집에서 털 수 있는 비용 + n - 2번째 집에서 털 수 있는 최대 비용, n - 1번째 집에서 털 수 있는 최대 비용).
 * -> 첫 번째 집부터 털면 마지막 집은 털지 못하고(원형으로 집이 배치되었기 때문에), 두 번째 집부터 털면 마지막 집을 털 수 있다.
 * -> 따라서, dp테이블을 2개 만들고, 2가지 방식 모두로 갱신한 뒤 최대 값을 출력한다.
 */

public class PM_L4_도둑질_r2 {
    public int solution(int[] money) {
        // 1번째 집부터 털 경우 시뮬레이션할 dp테이블을 만든다.
    	int[] dp1 = new int[money.length];
    	// 첫 번째 집부터 선택하기 때문에 dp[0]와 dp[1]은 첫 번째 집으로 초기화한다.
    	dp1[0] = money[0];
    	dp1[1] = money[0];
    	// 2번째 집부터 털 경우 시뮬레이션할 dp테이블을 만든다.
    	int[] dp2 = new int[money.length];
    	// 두 번째 집부터 선택하기 때문에 dp[0] = 0, dp[1]은 두 번째 집으로 초기화한다.
    	dp2[0] = 0;
    	dp2[1] = money[1];
    	
    	// 세 번째 집부터 n번째 집 까지 방문하며 최대 비용을 갱신한다.
    	for(int i = 2; i < money.length; i++) {
    		dp1[i] = Math.max(money[i] + dp1[i - 2], dp1[i - 1]);
    		dp2[i] = Math.max(money[i] + dp2[i - 2], dp2[i - 1]);
    	}
    	
    	// 둘 중 더 큰 값을 반환한다.
        return Math.max(dp1[money.length - 2], dp2[money.length - 1]);
    }
}

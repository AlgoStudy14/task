import java.util.Scanner;

public class BOJ_S3_1로만들기 {
	/*
	 * <문제>
	 * 1. X가 3으로 나누어 떨어지면 3으로 나눔.
	 * 2. 2로 나누어 떨어지면 2로 나눔.
	 * 3. 1을 뺌.
	 * 이 3개를 적절히 사용해 1을 만들기. 연산을 하는 최솟값은?
	 * 
	 * <문제풀이>
	 * 10^6 보다 작은 N이므로 dfs나 백트래킹?불가
	 * 1 = 0, 2 = 1, 3 = 1, 4 = 2, 5 = 3, 6 = 2, 7 = 3, 8 = 3, 9 = 2, 10 = 4, 11 = 5, 12 = 3, 13 = 4, 14 = 4, 15 = 4, 16 = 4
	 * 17 = 5, 18 = 3, 19 = 4, 20 = 5
	 * DP 배열 이용해서 입력받은 N 까지 배열에 넣어서 계산 할 것.
	 * 1. 나누어떨어지지 않는 수 같은 경우 3번의 경우로 인해 단순히 1번 연산이 늘어남.
	 * 2. 나누어 떨어지면 이전 연산 + 1번 늘어난 것과 나누어 떨어진 것에서 1을 더한 것 중 어느 것이 큰지 확인.
	 * 
	 * <문제>
	 * 10부터 틀리는듯.. 왜지??? 2로 나누어떨어져서 dp[5] + 1, dp[5] = dp[4]+1. dp[4] = dp[2]+1인데.	? 10이 3이네?? 아 1을 빼고 dp[9] + 1이라서 맞구나 위에 나열이 틀렸네
	 */
	
	static int N;
	static int[] dp = new int[1000001];	//10^6 
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		N = sc.nextInt();
		dp[1] = 0;
		dp[2] = 1;
		dp[3] = 1;
		
		for(int i = 4; i <= N; i++) {
			dp[i] = dp[i - 1] + 1;
			
			if(i % 3 == 0)
				dp[i] = Math.min(dp[i], dp[i/3] + 1);
			if(i % 2 == 0)
				dp[i] = Math.min(dp[i], dp[i/2] + 1);
		}
		System.out.println(dp[N]);
	}
}

package s0619;

/*
 * (완)
 * <문제 요약>
 * 문제 정의 : 2차원 좌표의 좌상단끝에서, 우하단끝까지 최단 경로로 이동할 수 있는 경로의 개수.
 * 문제 유형 : DP.
 * 주의 사항 : 최단 경로의 개수가 매우 많을 수 있으므로, 모듈러 산술을 적절히 활용해주어야 한다.
 * 주의 사항2 : 문제의 좌표는 기존 수학에서 사용하는 좌표를 사용하고 있다. 적절히 행렬의 행과 열 표현 방식으로 바꾸어 주어야 한다.
 * <풀이 요약 : DP>
 * 1. 2차원 dp 테이블을 만든다.
 * 2. 방문 불가능 지역을 -1로 초기화한다.
 * 3. 맵의 좌상단부터 우하단까지 탐색하면서, dp 테이블의 각 칸의 우측 열에 해당하는 칸과 아래 행에 해당하는 칸의 값을 갱신한다.
 * -> 단, 맵을 벗어나는 경우는 생략한다.
 * -> 단, 이동할 수 없는 칸은 생략한다.
 * -> 단, 갱신이 일어날 때 항상 1,000,000,007로 mod 연산을 수행해준다.
 */

public class PM_L3_등굣길 {
	public static void main(String[] args) {
		int m = 4;
		int n = 3;
		int[][] puddles = { { 2, 2 } };
		solution(m, n, puddles);
	}

	public static int solution(int m, int n, int[][] puddles) {
		int div = 1_000_000_007;

		// dp 테이블을 만들고, 좌상단의 값을 1로 초기화한다.
		int[][] dp = new int[n][m];
		dp[0][0] = 1;

		// 방문 불가능 지역을 -1로 초기화한다.
		for (int i = 0; i < puddles.length; i++) {
			int row = puddles[i][1] - 1;
			int col = puddles[i][0] - 1;
			dp[row][col] = -1;
		}

		// 맵의 좌상단부터 우하단까지 탐색한다.
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				// dp 테이블의 현재 칸이 맵 상에서 방문 불가능이라면 생략.
				if (dp[i][j] == -1) {
					continue;
				}
				// 오른쪽 칸이 존재하지 않는 경우와 이동할 수 없는 경우는 생략한다.
				if (j + 1 < m && dp[i][j + 1] != -1) {
					// dp 테이블의 현재 칸에 대하여 오른쪽 칸의 값을 dp 테이블의 현재 칸 + dp 테이블의 현재 칸으로 갱신한다.
					dp[i][j + 1] = (dp[i][j] + dp[i][j + 1]) % div;
				}
				// 아래쪽 칸이 존재하지 않는 경우와 이동할 수 없는 경우는 생략한다.
				if (i + 1 < n && dp[i + 1][j] != -1) {
					// dp 테이블의 현재칸에 대하여 아래쪽 칸의 값은 그대로 전달한다.
					dp[i + 1][j] = dp[i][j] % div;
				}
			}
		}

		return dp[n - 1][m - 1];
	}
}

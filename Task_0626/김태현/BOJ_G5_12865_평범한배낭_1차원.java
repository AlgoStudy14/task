package s0626;

import java.util.Scanner;

/*
 * <문제 요약>
 * 문제 정의 : 배낭에 넣을 수 있는 물건들의 가치의 최댓값.
 * 문제 유형 : DP.
 * 
 * <풀이 요약 : DP : 개선>
 * 1. 각 무게당 가질 수 있는 가치의 최대합을 저장할 1차원 dp테이블을 만든다.
 * 2. 점화식.
 * -> dp[k] = Math.max(dp[k], dp[k - W] + 물건의 가치)해당 점화식을 모든 물건에 대하여 계산해보며 값을 갱신한다.
 * -> 단, 앞에서 부터 갱신을 시작한다면 부분 문제 해결에 앞의 값이 사용되기 때문에 같은 물건을 한 번 더 넣게 되는 문제가 발생한다.
 * -> 따라서, 뒤에서  부터 값을 갱신하고 이전에 해결한 문제가 다음 문제에서 사용되지 않도록 방식을 바꾸어준다.
 * 3. dp[K]을 출력한다.
 * <피드백>
 * DP는 부분문제의 해를 바탕으로 주어진 문제의 해를 차례차례 구해가는 과정이다. 
 * 그런데 2차원 dp테이블을 만드는 경우에는 열을 채워나가는 부분 문제 구조와, 행을 채워나가는 부분 문제 구조가 2가지 존재할 수 있다.
 * (이 문제의 경우, 각 무게에 대하여 값을 갱신해나가는 과정 - 열에 대한 부분 문제/ 각 물건에 대하여 값을 갱신해나가는 과정 - 행에 대한 부분 문제로 나뉜다).
 * 이때, 이 문제에서 열에 대한 부분 문제를 구하는 과정은 앞에서 부터 계산한다면 한 행에 대해서는 최적 부분문제 구조가 성립하지만, 
 * 다음 행(즉, 행에 대한 부분 문제)에 대해서는 최적 부분문제구조가 성립하기 위해서는 이전에 구한 해들을 따로 기억해두고 있어야만 한다. 
 * 다만 이 문제에서는 열에 대한 부분 문제를 갱신하는 과정을 앞에서 부터 하는 것이 아닌 뒤에서 부터 해준다면 행에 대한 최적 부분문제구조가 성립함을 할 수 있다.
 * 따라서, 1차원 dp테이블을 이용하여 문제를 해결할수도 있는 것이다.
 */

public class BOJ_G5_12865_평범한배낭_1차원 {
	static int N, K;
	static int[] dp;
	static int[][] items;

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		N = sc.nextInt();
		K = sc.nextInt();
		items = new int[N][2];
		for (int i = 0; i < N; i++) {
			// 무게
			items[i][0] = sc.nextInt();
			// 가치
			items[i][1] = sc.nextInt();
		}
		// 1차원 dp 테이블 선언(초기에는 물건을 0개를 넣은 것이므로, 배열을 0으로 초기화 해주면 된다).
		dp = new int[K + 1];
		// dp 테이블 갱신
		// 1번째 물건부터 N번째 물건 까지 모든 경우를 고려한다.
		for (int i = 0; i < N; i++) {
			// 모든 무게에 대하여 고려하되, 앞에서 갱신된 부분이 뒤 무게에 대한 부분 문제를 풀이할 때 사용되지 않도록 뒤에서부터 계산한다.
			for (int j = K; j >= items[i][0]; j--) {
				// N - 1번째 dp테이블은 N - 1번째 물건 까지의 해당 무게에서의 최대값을 의미한다.
				// 따라서, 현재 무게에서 이전 무게까지 구해진 최대 값과 현재 고려하는 물건을 포함시킨 가치를 비교하여 dp 테이블을 갱신한다.
				dp[j] = Math.max(dp[j], dp[j - items[i][0]] + items[i][1]);
			}
		}
		// dp[K]를 출력한다.
		System.out.println(dp[K]);
		sc.close();
	}
}
